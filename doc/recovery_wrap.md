# Упрощаем написание HTTP обработчиков на Golang

## Почему Golang

Компания, в которой я работаю, специализируется на решениях Oracle. Обычно REST API мы делали с использованием [Oracle REST Data Services](https://www.oracle.com/database/technologies/appdev/rest.html). Но импортозамещение заставило нас обратить внимание в сторону свободного ПО.  
[В ходе тестирования REST API на Golang были получены неплохие показатели производительности](https://habr.com/ru/post/488948/).  

HTTP сервер на Go пишется легко, не требует стороннего ПО для работы, запускается под любой платформой.

## Типовой обработчик входящего HTTP запроса

Типовой обработчик входящего HTTP запроса в моем сервере для REST API на Golang выполняется следующие действия:

- Логирование входящего HTTP запроса (детальность логирования настраивается)
- Проверка на допустимость HTTP метода (формирует ошибку http.StatusMethodNotAllowed)
- Проверка режима аутентификации (basic, MS AD, JSON web token)
- Выполнение аутентификации (basic, MS AD)
- Проверка валидности JSON web token
- Считывание тела (body) входящего запроса
- Считывание заголовка (header) входящего запроса
- **Собственно обработка запроса и формирование ответа**
- Установка HSTS Strict-Transport-Security
- Установка Content-Type для исходящего ответа (response)
- Логирование исходящего HTTP ответа
- Запись заголовка (header) исходящего ответа
- Зпись тела исходящего ответа
- Обработка ошибок
- Обработка defer recovery для восстановления после возможной panic

Большая часть этих действий является типовыми и не зависят от типа запроса и его обработки.  
Повторять их в каждом HTTP обработчике крайне не эффективно.  
Даже если вынести весь код в отдельные подфункции, все равно получается примерно по 80-100 строк кода на каждый HTTP обработчик без учета собственно **обработки запроса и формирования ответа**. 

Ниже описан подход, как можно упросить написание HTTP обработчиков на Golang без использования кодогенераторов и сторонних библиотек.  
У любого опытного разработчика, естественно, есть свои устоявшиеся приемы и наработки - буду рад, если кто-то поделится своими подходами. 

## Пример HTTP обработчика Echo

Сначала покажу пример echo бработчика, которые написан в таком подходе.  
Он занимает ровно 9 строк (без учета комментариев).  
``` go
func (s *Service) EchoHandler(w http.ResponseWriter, r *http.Request) {
    // Запускаем универсальный обработчик HTTP запросов 
	s.Process("POST", w, r, func(requestBuf []byte, reqID uint64) ([]byte, Header, int, error) {
		header := Header{} // заголовок ответа

        // Считаем параметры из заголовка входящего запроса и поместим их в заголовок ответа
		for key := range r.Header {
			header[key] = r.Header.Get(key)
		}
        // возвращаем буфер запроса в качестве ответа, заголовок ответа и статус 
		return requestBuf, header, http.StatusOK, nil
	})
}
```

## Подход к организации HTTP обработчиков на Golang

На следующем рисунке показана упрощенная UML диаграмма выполнения HTTP обработчика на примере выше описанного Echo handler. 

Идея достаточно простая:
- На верхнем уровне необходимо внедрить defer фукнцию для восстановления после паники. Это нужно делать обязательно, иначе падает весь сервер. На UML диаграмме это функция RecoverWrap - показана красным цветом.
- Весь типовой код необходимо вынести в отдельный обработчик. Этот обраотчик встраивается в наш HTTP handler. На UML диаграмме это функция Process - показана синим цветом.
- Собственно код функциональной обработки запроса и формирования ответа вынесен в анонимную функцию. На UML диаграмме это функция EchoHandler.func1 - показана зеленым цветом.

![http_handler](https://raw.githubusercontent.com/romapres2010/httpserver/master/img/http_handler.png)


