# Упрощаем написание HTTP обработчиков на Golang

## Почему Golang

Компания, в которой я работаю, специализируется на решениях Oracle. Обычно REST API мы делали с использованием [Oracle REST Data Services](https://www.oracle.com/database/technologies/appdev/rest.html). Но импортозамещение заставило нас обратить внимание в сторону свободного ПО.  
[В ходе тестирования REST API на Golang были получены неплохие показатели производительности](https://habr.com/ru/post/488948/).  

HTTP сервер на Go пишется легко, не требует стороннего ПО для работы, запускается под любой платформой.

## Типовой обработчик входящего HTTP запроса

Типовой обработчик входящего HTTP запроса в моем сервере для REST API на Golang выполняется следующие действия:

- Логирование входящего HTTP запроса (детальность логирования настраивается)
- Проверка на допустимость HTTP метода (формирует ошибку http.StatusMethodNotAllowed)
- Проверка режима аутентификации (basic, MS AD, JSON web token)
- Выполнение аутентификации (basic, MS AD)
- Проверка валидности JSON web token
- Считывание тела (body) входящего запроса
- Считывание заголовка (header) входящего запроса
- **Собственно обработка запроса и формирование ответа**
- Установка HSTS Strict-Transport-Security
- Установка Content-Type для исходящего ответа (response)
- Логирование исходящего HTTP ответа
- Запись заголовка (header) исходящего ответа
- Зпись тела исходящего ответа
- Обработка ошибок
- Обработка defer recovery для восстановления после возможной panic

Большая часть этих действий является типовыми и не зависят от типа запроса и его обработки.  
Повторять их в каждом HTTP обработчике крайне не эффективно.  
Даже если вынести весь код в отдельные подфункции, все равно получается примерно по 80-100 строк кода на каждый HTTP обработчик без учета собственно **обработки запроса и формирования ответа**. 

Ниже описан подход, как можно упросить написание HTTP обработчиков на Golang без использования кодогенераторов и сторонних библиотек.  
У любого опытного разработчика, естественно, есть свои устоявшиеся приемы и наработки - буду рад, если кто-то поделится своими подходами. 

## Пример HTTP обработчика Echo

Сначала покажу пример echo бработчика, которые написан в таком подходе.  
Он занимает ровно 9 строк (без учета комментариев).  
``` go
func (s *Service) EchoHandler(w http.ResponseWriter, r *http.Request) {
    // Запускаем универсальный обработчик HTTP запросов 
	s.Process("POST", w, r, func(requestBuf []byte, reqID uint64) ([]byte, Header, int, error) {
		header := Header{} // заголовок ответа

        // Считаем параметры из заголовка входящего запроса и поместим их в заголовок ответа
		for key := range r.Header {
			header[key] = r.Header.Get(key)
		}
        // возвращаем буфер запроса в качестве ответа, заголовок ответа и статус 
		return requestBuf, header, http.StatusOK, nil
	})
}
```

## Подход к организации HTTP обработчиков на Golang

На следующем рисунке показана упрощенная UML диаграмма выполнения HTTP обработчика на примере выше описанного EchoHandler. 

Идея достаточно простая:
- На верхнем уровне необходимо внедрить defer фукнцию для восстановления после паники. Это нужно делать обязательно, иначе падает весь сервер. На UML диаграмме - это анонимная функция RecoverWrap.func1, показаная красным цветом.
- Весь типовой код необходимо вынести в отдельный обработчик. Этот обработчик встраивается в наш HTTP handler. На UML диаграмме это функция Process - показана синим цветом.
- Собственно код функциональной обработки запроса и формирования ответа вынесен в анонимную функцию в нашем HTTP handler. На UML диаграмме это функция EchoHandler.func1 - показана зеленым цветом. 

![http_handler](https://raw.githubusercontent.com/romapres2010/httpserver/master/img/http_handler.png)

## Пример кода

При регистрация обработчика в роутере, регистрируется не собственно обработчик EchoHandler, а анонимная функция обработки паники (она возвращается функцией RecoverWrap), котрая уже вызывает наш обработчик EchoHandler.
``` go
router.HandleFunc("/echo", service.RecoverWrap(http.HandlerFunc(service.EchoHandler))).Methods("GET")
```

Текст функции RecoverWrap для регистрации анонимной функции обработки паники.  
После объявления defer func() запускается собственно наш обработчик EchoHandler.
``` go
func (s *Service) RecoverWrap(handlerFunc http.HandlerFunc) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// объявляем функцию восстановления после паники
		defer func() {
			var err error
			r := recover()
			if r != nil {
				switch t := r.(type) {
				case string:
					err = errors.New(t)
				case error:
					err = t
				default:
					err = errors.New("UNKNOWN ERROR")
				}
				// формируем текст ошибки для логирования
				myerr := myerror.New("8888", fmt.Sprintf("UNKNOWN ERROR - recover from panic \n %+v", err.Error()), "RecoverWrap", "")
				// кастомное логирование ошибки
				s.LogError(myerr, w, http.StatusInternalServerError, 0)
			}
		}()

		// вызываем обработчик
		if handlerFunc != nil {
			handlerFunc(w, r)
		}
	})
}
```